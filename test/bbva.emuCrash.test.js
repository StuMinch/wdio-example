describe('VMD-673', () => {
  
    it('should tap the welcome button', async () => {
      const welcomeBtn = await $("//android.widget.Button[contains(@resource-id,\"welcomeTopButton\")]");
      await welcomeBtn.click();
    });

    it('should tap the text field', async () => {
        const textField = await $("//*[@resource-id=\"co.com.bbva.mb.dev:id/editText\"]");
        await textField.click();
        await textField.setValue('19481809');
        await driver.execute('mobile: performEditorAction', {'action': 'send'});
    });

    it('should tap the next button', async () => {
        const welcomeBtn = await $("//android.widget.Button[@resource-id=\"co.com.bbva.mb.dev:id/nextButton\"]");
        await welcomeBtn.click();
    });

    it('should tap the password field', async () => {
        const textField = await $("//*[@resource-id=\"co.com.bbva.mb.dev:id/passwordEditText\"]//*[@resource-id=\"co.com.bbva.mb.dev:id/editText\"]");
        await textField.click();
        await textField.setValue('Prueba01');
        await driver.execute('mobile: performEditorAction', {'action': 'send'});
    });

    it('should tap the login button', async () => {
        const loginBtn = await $("//android.widget.Button[@resource-id=\"co.com.bbva.mb.dev:id/loginButton\"]");
        await loginBtn.click();
    });

    it('should switch context to webview', async () => {
        await driver.switchContext("WEBVIEW_co.com.bbva.mb.dev");
    });

    it('should click a button within shadow DOM', async () => {
        await browser.executeScript("function shadowElement({\n  selector,\n  multiple,\n  baseElement\n}) {\n  return _querySelectorDeep(selector, multiple, baseElement || document);\n  function _querySelectorDeep(selector, findMany, root) {\n    selector = normalizeSelector(selector);\n    let lightElement = root.querySelector(selector);\n    if (document.head.createShadowRoot || document.head.attachShadow) {\n      // no need to do any special if selector matches something specific in light-dom\n      if (!findMany && lightElement) {\n        return lightElement;\n      }\n\n      // split on commas because those are a logical divide in the operation\n      const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');\n      return selectionsToMake.reduce((acc, minimalSelector) => {\n        // if not finding many just reduce the first match\n        if (!findMany && acc) {\n          return acc;\n        }\n        // do best to support complex selectors and split the query\n        const splitSelector = splitByCharacterUnlessQuoted(minimalSelector\n        //remove white space at start of selector\n        .replace(/^\\s+/g, '').replace(/\\s*([>+~]+)\\s*/g, '$1'), ' ')\n        // filter out entry white selectors\n        .filter(entry => !!entry);\n        const possibleElementsIndex = splitSelector.length - 1;\n        const possibleElements = collectAllElementsDeep(splitSelector[possibleElementsIndex], root);\n        const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);\n        if (findMany) {\n          acc = acc.concat(possibleElements.filter(findElements));\n          return acc;\n        } else {\n          acc = possibleElements.find(findElements);\n          return acc || null;\n        }\n      }, findMany ? [] : null);\n    } else {\n      if (!findMany) {\n        return lightElement;\n      } else {\n        return root.querySelectorAll(selector);\n      }\n    }\n  }\n  function findMatchingElement(splitSelector, possibleElementsIndex, root) {\n    return element => {\n      let position = possibleElementsIndex;\n      let parent = element;\n      let foundElement = false;\n      while (parent && !isDocumentNode(parent)) {\n        const foundMatch = parent.matches(splitSelector[position]);\n        if (foundMatch && position === 0) {\n          foundElement = true;\n          break;\n        }\n        if (foundMatch) {\n          position--;\n        }\n        parent = findParentOrHost(parent, root);\n      }\n      return foundElement;\n    };\n  }\n  function splitByCharacterUnlessQuoted(selector, character) {\n    return selector.match(/\\\\?.|^$/g).reduce((p, c) => {\n      if (c === '\"' && !p.sQuote) {\n        p.quote ^= 1;\n        p.a[p.a.length - 1] += c;\n      } else if (c === '\\'' && !p.quote) {\n        p.sQuote ^= 1;\n        p.a[p.a.length - 1] += c;\n      } else if (!p.quote && !p.sQuote && c === character) {\n        p.a.push('');\n      } else {\n        p.a[p.a.length - 1] += c;\n      }\n      return p;\n    }, {\n      a: ['']\n    }).a;\n  }\n\n  /**\n   * Checks if the node is a document node or not.\n   * @param {Node} node\n   * @returns {node is Document | DocumentFragment}\n   */\n  function isDocumentNode(node) {\n    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;\n  }\n  function findParentOrHost(element, root) {\n    const parentNode = element.parentNode;\n    return parentNode && parentNode.host && parentNode.nodeType === 11 ? parentNode.host : parentNode === root ? null : parentNode;\n  }\n\n  /**\n   * Finds all elements on the page, inclusive of those within shadow roots.\n   * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'\n   * @return {!Array<string>} List of anchor hrefs.\n   * @author ebidel@ (Eric Bidelman)\n   * License Apache-2.0\n   */\n  function collectAllElementsDeep(selector = null, root) {\n    const allElements = [];\n    const findAllElements = function (nodes) {\n      for (let i = 0, el; el = nodes[i]; ++i) {\n        allElements.push(el);\n        // If the element has a shadow root, dig deeper.\n        if (el.shadowRoot) {\n          findAllElements(el.shadowRoot.querySelectorAll('*'));\n        }\n      }\n    };\n    if (root.shadowRoot) {\n      findAllElements(root.shadowRoot.querySelectorAll('*'));\n    }\n    findAllElements(root.querySelectorAll('*'));\n    return selector ? allElements.filter(el => el.matches(selector)) : allElements;\n  }\n\n  // normalize-selector-rev-02.js\n  /*\n    author: kyle simpson (@getify)\n    original source: https://gist.github.com/getify/9679380\n     modified for tests by david kaye (@dfkaye)\n    21 march 2014\n     rev-02 incorporate kyle's changes 3/2/42014\n  */\n\n  /*  istanbul ignore next */\n  function normalizeSelector(sel) {\n    // save unmatched text, if any\n    function saveUnmatched() {\n      if (unmatched) {\n        // whitespace needed after combinator?\n        if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {\n          tokens.push(' ');\n        }\n\n        // save unmatched text\n        tokens.push(unmatched);\n      }\n    }\n    var tokens = [],\n      match,\n      unmatched,\n      regex,\n      state = [0],\n      next_match_idx = 0,\n      prev_match_idx,\n      not_escaped_pattern = /(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/,\n      whitespace_pattern = /^\\s+$/,\n      state_patterns = [/\\s+|\\/\\*|[\"'>~+\\[\\(]/g,\n      // general\n      /\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g,\n      // [..] set\n      /\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g,\n      // (..) set\n      null,\n      // string literal (placeholder)\n      /\\*\\//g // comment\n      ];\n\n    sel = sel.trim();\n    while (true) {\n      unmatched = '';\n      regex = state_patterns[state[state.length - 1]];\n      regex.lastIndex = next_match_idx;\n      match = regex.exec(sel);\n\n      // matched text to process?\n      if (match) {\n        prev_match_idx = next_match_idx;\n        next_match_idx = regex.lastIndex;\n\n        // collect the previous string chunk not matched before this token\n        if (prev_match_idx < next_match_idx - match[0].length) {\n          unmatched = sel.substring(prev_match_idx, next_match_idx - match[0].length);\n        }\n\n        // general, [ ] pair, ( ) pair?\n        if (state[state.length - 1] < 3) {\n          saveUnmatched();\n\n          // starting a [ ] pair?\n          if (match[0] === '[') {\n            state.push(1);\n          }\n          // starting a ( ) pair?\n          else if (match[0] === '(') {\n            state.push(2);\n          }\n          // starting a string literal?\n          else if (/^[\"']$/.test(match[0])) {\n            state.push(3);\n            state_patterns[3] = new RegExp(match[0], 'g');\n          }\n          // starting a comment?\n          else if (match[0] === '/*') {\n            state.push(4);\n          }\n          // ending a [ ] or ( ) pair?\n          else if (/^[\\]\\)]$/.test(match[0]) && state.length > 0) {\n            state.pop();\n          }\n          // handling whitespace or a combinator?\n          else if (/^(?:\\s+|[~+>])$/.test(match[0])) {\n            // need to insert whitespace before?\n            if (tokens.length > 0 && !whitespace_pattern.test(tokens[tokens.length - 1]) && state[state.length - 1] === 0) {\n              // add normalized whitespace\n              tokens.push(' ');\n            }\n\n            // case-insensitive attribute selector CSS L4\n            if (state[state.length - 1] === 1 && tokens.length === 5 && tokens[2].charAt(tokens[2].length - 1) === '=') {\n              tokens[4] = ' ' + tokens[4];\n            }\n\n            // whitespace token we can skip?\n            if (whitespace_pattern.test(match[0])) {\n              continue;\n            }\n          }\n\n          // save matched text\n          tokens.push(match[0]);\n        }\n        // otherwise, string literal or comment\n        else {\n          // save unmatched text\n          tokens[tokens.length - 1] += unmatched;\n\n          // unescaped terminator to string literal or comment?\n          if (not_escaped_pattern.test(tokens[tokens.length - 1])) {\n            // comment terminator?\n            if (state[state.length - 1] === 4) {\n              // ok to drop comment?\n              if (tokens.length < 2 || whitespace_pattern.test(tokens[tokens.length - 2])) {\n                tokens.pop();\n              }\n              // otherwise, turn comment into whitespace\n              else {\n                tokens[tokens.length - 1] = ' ';\n              }\n\n              // handled already\n              match[0] = '';\n            }\n            state.pop();\n          }\n\n          // append matched text to existing token\n          tokens[tokens.length - 1] += match[0];\n        }\n      }\n      // otherwise, end of processing (no more matches)\n      else {\n        unmatched = sel.substr(next_match_idx);\n        saveUnmatched();\n        break;\n      }\n    }\n    return tokens.join('').trim();\n  }\n}");
    
        const button = await browser.executeAsync(
          (selector) => {
            return window.__radishShadow(selector, false);
          },
          ["#cells-template-welcomeExperience[state=\"active\"] #slider"]
        );
    
        await button.click();
    
        // Assert the result of the button click
    });

    

})